1. 낙관적 잠금
- 충돌이 발생하지 않는다는 가정하에 Lock을 걸지 않는 방식
- 대신, 데이터를 읽은 시점에 숫자형으로 이루어진 버전값을 사용한다.
- 데이터 버전이 이전에 읽은 버전과 동일한 경우 업데이트가 성공하고 버전이 증가한다.
- 만약, 다른 트랜잭션이 데이터를 업데이트한 경우 버전이 달라지기 때문에 예외를 던진다
- 장점은 Lock을 사용하지 않기 때문에 단순하고 높은 동시성을 허용한다.
- 단점은 충돌이 발생하면 실패처리된 트랜잭션의 처리(롤백 처리 혹은 재시도 로직)를 해줘야 한다.
- 예시
  ```
    💡선착순 100명에게 쿠폰을 발급하는 이벤트
     동시에 100명이 요청했을 경우, 낙관적 락(Optimistic Lock) 메커니즘상 최초의 커밋만 인정하기 때문에 
     100개의 쿠폰이 있어도 최초 요청한 1명에게만 쿠폰이 발급된다. 그럼 나머지 99명은 다시 발급 요청을
     해야 한다. 
  
     어플리케이션 서버는 재시도하는 요청만큼 부하를 받게 되고, 재시도에 대한 처리와 실패에 대한 처리도 
     구현해야 하므로 코드의 복잡성이 증가할 수 있다.
  ```

2. 비관적 잠금
- 충돌이 발생할것이라고 가정하여 트랜잭션이 완료될 때까지 데이터를 잠가 다른 트랜잭션이 그 동안
  데이터를 수정하지 못하도록 사용하는 방식
- 락은 가진 프로세스만 데이터에 접근할 수 있다.
- 트랜잭션이 시작될 때 Shared Lock 또는 Exclusive Lock을 걸고 시작한다.
  - Shared Lock(공유, 읽기 잠금, s-lock)
    - 데이터를 읽을 때 사용하는 Lock
    - 다른 s-Lock과 한 리소스에 두개 이상의 Lock을 동시에 설정할 수 있지만, x-Lock은 설정 불가
    - 즉 여러 트랜잭션에서 동시에 하나의 데이터를 읽을 수 있다. 그러나 변경중인 리소스를 동시에 읽을 수는 없다.
    - SQL 명령은 SELECT ... LOCK IN SHARE MODE
    - JPA의 LockModeType.PESSIMISTIC_READ
  - Exclusive Lock(베타, 쓰기 잠금, x-lock)
    - 데이터를 변경할 때 사용
    - 다른 Lock들과 호환되지 않기 때문에, 한 리소스에 하나의 x-Lock만 설정 가능
    - 다른 트랜잭션에서 읽기, 쓰기가 불가능하기 때문에, 한 트랜잭션에 하나의 리소스만 사용할 수 있다.
    - SQL 명령은 SELECT ... FOR UPDATE
    - JPA의 LockModeType.PESSIMISTIC_WRITE
- 장점은 데이터의 일관성이 보장된다.
- 단점은 잠금으로 인한 대기 시간으로 인해 애플리케이션의 처리량이 감소할 수 있다. 잘못하면 교착상태가
  발생할 수도 있다. 
  ```
    💡교착상태란?
     둘 이상의 프로세스(트랜잭션)들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며
     무한정 기다리는 상황
  ```
- 일반적으로 동시성이 낮은 상황이나 데이터 충돌 가능성이 높고 비즈니스상의 이유로 충돌 방지가 중요한
  경우에만 사용한다.

3. Named 잠금
- 이름을 가진 메타데이터 락
- 이름을 부여하여 락을 획득하고 반납하는 잠금으로, 한 세션이 Lock을 획득한다면, 다른 세션은 해당 
  세션이 Lock을 해제한 이후 획득할 수 있다. 
- Lock에 이름을 지정하여 어플리케이션 단에서 제어가 가능하다.
- MySQL 을 사용해 분산 락을 구현할 수 있다.
- 단점으로는 Lock이 자동으로 해제되지 않기 때문에, 별도의 명령어로 해제를 수행해주거나 선점시간이 
  끝나야 해제하는 등 락의 획득,반납에 대한 로직을 철저하게 구현해야한다.

4. Redis를 활용한 분산 락
- Lock에 대한 정보를 Redis에 보관
- 분산 환경의 서버는 공통된 Redis를 통해 임계 영역(critical section)에 접근할 수 있는지 확인

4-1. Lettuce 방식
- Setnx 명령어를 활용하여 분산락을 구현한다.
- Setnx는 Lock을 획득하려는 스레드가 Lock 획득 가능여부의 확인을 반복적으로 시도하는 스핀 락(Spin Lock) 방식
- 장점은 구현이 간단하다. 
- 재시도가 필요하지 않은 락일 경우 사용한다.
  - 예시
    ```
      💡개수제한이 있는(선착순) 제품에 대한 주문시
        유저 A 가 로지텍마우스를 구매
        동시에 유저 B 도 로지텍마우스를 구매
        유저 A 가 먼저 Lock 을 잡고있다면 유저B 는 재시도를 할 필요없음
    ```
- 단점은 스핀 락 방식이기 때문에 지속적으로 락의 획득을 시도하면서 Redis에 많은 부하가 생긴다.
  이를 위해, 일정 시간만큼 sleep 하면서 개선하지만 역시 Redis에 부하가 생긴다.
- 또한, 계속 락을 획득하기 위해 시도하는 중, 락을 가지고 있는 스레드가 비정상적으로 종료되면서 
  무한 대기상태로 빠질 수 있다. 그래서 락을 획득하는 최대 허용시간이나 최대 허용횟수를 지정해야 한다.

4-2. Redisson 방식
- Pub-sub 방식으로 Lock 을 구현
  ```
    💡Pub-Sub 방식이란?
     별도의 채널을 만들고, 락을 점유중인 스레드의 락이 해제될 때마다 대기중인 스레드에게 알림을 주어 
     대기중인 스레드가 락 점유를 시도하는 방식
  ```
- Lettuce와 다르게 Redis의 부하를 줄일 수 있으며 별도의 Retry 로직을 작성하지 않아도 된다.
- 락 획득 재시도를 기본적으로 제공해준다.
- 재시도가 필요한 락일 경우 사용한다.
  - 예시
    ```
      💡개수제한이 없는 제품에 대한 주문시
        유저 A 가 로지텍마우스를 구매
        동시에 유저 B 도 로지텍마우스를 구매
        유저 A 가 먼저 Lock 을 잡고있다면 유저B 는 기다렸다가 재시도를 하여 로지텍마우스를 구매
    ```
- 단점으로는 라이브러리를 학습해야 한다.

4-3. Sorted Set 방식
- 선착순 이벤트시 동시성 처리를 위해 사용하는 방식 중 하나
- 모든 요청이 DB에 바로 부하가 가지 않고 차례대로 일정 범위만큼씩 처리
- Sorted Sets은 key 하나에 여러개의 score와 value로 구성하는 자료구조
  - 한 Key에 여러 value와 score를 가지고 있으며 중복되지 않는 value로 score순으로 데이터를 정렬
  - 예시:
    - key: 이벤트 이름
    - value: 사용자를 구분할 수 있는 고유값
    - score: 유닉스타임(m/s)

참고
- https://url.kr/q8ldpu
- https://velog.io/@hyojhand/named-lock-distributed-lock-with-redis
- https://url.kr/9q6hl1
- https://velog.io/@hgs-study/redis-sorted-set
- https://url.kr/9i1bse